package com.jonathan.survivor;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.GL10;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.glutils.ShapeRenderer;
import com.badlogic.gdx.graphics.glutils.ShapeRenderer.ShapeType;
import com.esotericsoftware.spine.Skeleton;
import com.jonathan.entity.Human.Direction;
import com.jonathan.entity.Player;
import com.jonathan.math.Vector2;
import com.jonathan.survivor.TerrainLayer.TerrainType;

/**
 * Renders the world and its GameObjects. Also stores the camera used to view the world.
 * @author Jonathan
 *
 */

public class WorldRenderer 
{	
	/** Stores the width and height of the world. This is the viewable region of the world, in world units. In other words, the camera size. 
	 *  The size is changed inside the resize() method according the aspect ratio of the screen. */
	private float worldWidth = Survivor.DEFAULT_WORLD_WIDTH;
	private float worldHeight = Survivor.DEFAULT_WORLD_HEIGHT;
	
	
	
	/** Stores the world whose level and gameObjects we render. */
	private World world;
	/** Stores the SpriteBatcher used to draw the GameObjects. */
	private SpriteBatch batcher;
	
	/** Stores the Assets singleton which stores all of the visual assets needed to draw the GameObjects. */
	private Assets assets = Assets.instance;
	
	/** Stores the OrthographicCamera used to view the world. */
	private OrthographicCamera worldCamera;
	
	private TerrainRenderer terrainRenderer;
	
	
	/** Creates a WorldRenderer instance used to draw the given world instance with the given SpriteBatch. */
	public WorldRenderer(World world, SpriteBatch batcher)
	{
		//Populates the member variables with their respective constructor arguments.
		this.world = world;
		this.batcher = batcher;
		
		//Creates the camera used to navigate and view the world. Initialized to the default width and height of the world.
		worldCamera = new OrthographicCamera(worldWidth, worldHeight);
		//Creates the ShapeRenderer instance used to draw the level geometry with lines.
		shapeRenderer = new ShapeRenderer();
		
		//Enables OpenGL ES to draw smooth lines to ensure level geometry looks anti-aliased.
		Gdx.gl.glEnable(GL10.GL_LINE_SMOOTH);
	}
	
	/** Called every frame when the game is running to update the position of the camera. MUST be called before render() method. */
	public void updateCamera()
	{
		worldCamera.position.x = world.getPlayer().getX();
		worldCamera.position.y = world.getPlayer().getY() + Player.COLLIDER_HEIGHT/2;
		//Updates the position of the camera.
		worldCamera.update();
	}
	
	/** Called every frame to render the contents of the world and update the camera. */
	public void render()
	{				
		//Renders the level geometry depending on the world's currently active level.
		renderLevel();
		
		//Renders the GameObjects to the screen.
		renderGameObjects();
	}
	
	/** Draws the GameObjects of the world to the screen. */
	private void renderGameObjects()
	{
		//Sets the projection matrix of the SpriteBatch to the camera's combined matrix. Ensure everything is drawn with the camera's coordinate system.
		batcher.setProjectionMatrix(worldCamera.combined);
		//Starts batching sprites to be drawn to the camera.
		batcher.begin();
		
		//Draws the player to the screen.
		drawPlayer();
		
		//Draws the sprites batched inside the SpriteBatcher.
		batcher.end();
	}
	
	/** Draws the player to the world camera. */
	private void drawPlayer()
	{
		//Gets the world's Player GameObject to extract the information to draw the player.
		Player player = world.getPlayer();
		//Gets the skeleton used to render the player to the screen and control his bones and animations.
		Skeleton playerSkeleton = world.getGOManager().getPlayerSkeleton();
		
		//If the player is looking left
		if(player.getDirection() == Direction.LEFT)
			//Flip his skeleton to look the other way. The skeleton looks right by default.
			playerSkeleton.setFlipX(true);
		//Else, if the player is facing right
		else
			//Don't flip his skeleton, since his skeleton is made to look to the right by default.
			playerSkeleton.setFlipX(false);
		
		//Set the player skeleton's bottom-center position to the bottom-center position of the Player GameObject.
		playerSkeleton.setX(player.getX());
		playerSkeleton.setY(player.getY());
		
		System.out.println(player.getPosition());
		
		//Updates the skeleton world transform. Must be done for unknown reasons.
		playerSkeleton.updateWorldTransform();
		//Updates the player's skeleton using the game's deltaTime value.
		playerSkeleton.update(Gdx.graphics.getDeltaTime());
		
		//Draws the skeleton using the universal SkeletonRenderer instance used by the game.
		assets.skeletonRenderer.draw(batcher, playerSkeleton);
	}
	
	/** Renders the level geometry depending on the world's currently active level. */
	private void renderLevel()
	{
		//If the world's currently active level is a TerrainLevel
		if(world.getLevel() instanceof TerrainLevel)
			//Renders the terrain of the world's level.
			renderTerrain();
	}
	
	/** Renders the terrain geometry of the world's currently active level using a lines */
	private void renderTerrain()
	{
		//Retrieves the TerrainLayers contained by the world's level. They are stored in a 2D array. These are the only layers we have to draw.
		TerrainLayer[][] layers = ((TerrainLevel)world.getLevel()).getTerrainLayers();
		
		//Sets the projection matrix of the ShapeRenderer to the world camera's, so that the shapes get rendered relative to world coordinates.
		shapeRenderer.setProjectionMatrix(worldCamera.combined);

		//Begins the shape rendering batch. We specify to draw lines.
		shapeRenderer.begin(ShapeType.Line);
		//Sets the line to be black.
		shapeRenderer.setColor(Color.LIGHT_GRAY);
		
		//Cycles through the rows of TerrainLayers
		for(int i = 0; i < layers.length; i++)
		{
			//Cycles through the columns of the TerrainLayers array.
			for(int j = 0; j < layers[i].length; j++)
			{
				//Stores the bottom left and right end-points of the TerrainLayer using TerrainLayer.getLeft/RightPoint():Vector2.
				Vector2 leftEndPoint = layers[i][j].getLeftPoint();
				Vector2 rightEndPoint = layers[i][j].getRightPoint();
				
				//If the TerrainType of the layer is not COSINE, the layer type is either CONSTANT or LINEAR. That means that the layer's geometry can be modeled 
				//using a straight line. Thus, draw a straight line.
				if(layers[i][j].getTerrainType() != TerrainType.COSINE)
				{
					//Draw a straight line going from the right end point to the left end point of the TerrainLayer. This draws the bottom portion of the layer since
					//the end points specify the position for the bottom of the layer.
					shapeRenderer.line(rightEndPoint.x, rightEndPoint.y, leftEndPoint.x, leftEndPoint.y);
					
					//If we are cycling through the last row of the layers array, we have reached the top-most layer. Thus, draw the top portion of the layer. It wasn't
					//necessary to do so before because the top-portion of the previous layers were drawn by the bottom portions of the next layers.
					if(i == layers.length-1)
						//Draws the top portion of the layer by drawing a line from the left end point to the right end point and off-setting it up by the layer height.
						shapeRenderer.line(rightEndPoint.x, rightEndPoint.y + TerrainLayer.LAYER_HEIGHT, leftEndPoint.x, leftEndPoint.y + TerrainLayer.LAYER_HEIGHT);
				}
				//Else, if we are here, the TerrainLayer has the geometry of a cosine function. Thus, draw the layer using a series of lines to model a cosine function.
				else
				{
					//Finds the width of each line segment by taking the width of the layer, and dividing it by the amount of segments we want.
					float segmentWidth = TerrainLayer.LAYER_WIDTH / COSINE_SEGMENTS;
					
					//Cycles from zero to the amount of desired segments to draw the cosine function with.
					for(int segment = 0; segment < COSINE_SEGMENTS; segment++)
					{
						//Stores the x-position of left-end of the segment. Found by taking the left end point of the layer, plus a segment width for each segment.
						float x1 = leftEndPoint.x + segmentWidth*segment;
						//Finds the x-position of the right-end of the segment simply by adding a segment width to the left-end's x-position.
						float x2 = x1 + segmentWidth;
						
						//Cap the segment's right-end x-position to the x-position of the right end-point of the layer. Ensure we don't draw too much.
						x2 = (x2 > rightEndPoint.x)? rightEndPoint.x : x2;
		
						//Draws a segment of the bottom of the cosine function. Renders a line going from the left-end segment to the right-end. Note that the y-value
						//of the segment is found using 'TerrainLayer.getBottomLayerHeight()'. We take the bottom height since we are drawing the bottom layer portion.
						shapeRenderer.line(x1, layers[i][j].getBottomLayerHeight(x1), x2, layers[i][j].getBottomLayerHeight(x2));
						
						//If we are cycling through the last row of the layers array, we have reached the top-most layer. Thus, draw the top portion of cosine function.
						//It wasn't necessary to do so before because the top-portion of the previous layers were drawn by the bottom portions of the next layers.
						if(i == layers.length-1)
							//Draws the top portion of the layer by drawing the cosine line segment from the left-end point of the segment to its right end-point and.
							//Note that the y-value of the segment is found using 'TerrainLayer.getTopLayerHeight()'. We take the top height since we are drawing 
							//the top portion of the layer.
							shapeRenderer.line(x1, layers[i][j].getTopLayerHeight(x1), x2, layers[i][j].getTopLayerHeight(x2));
					}
				}
			}
		}
		
		//Commits the lines to the ShapeRenderer and draws them to the screen.
		shapeRenderer.end();
	}
	
	/** Called when the screen is resized, or when the world renderer is first created. Resizes the camera to adjust to the new aspect ratio. Note that the parameters
	 *  specify the new width and height that the camera should have. Third parameter specifies a screen scale. This should be the factor the view frustum had to be
	 *  stretched to fit the target device. The level's line thickness is multiplied by this factor to compensate for a larger or smaller screen. */
	public void resize(float worldWidth, float worldHeight, float screenScale)
	{
		//Updates the width and height of the world. This is the viewable area of the world. I.e., the camera's size.
		worldWidth = worldWidth;
		worldHeight = worldHeight;
		
		//Updates the size of the camera to the values passed as parameters. The parameters specify the new size the camera should have. It was computed inside GameScreen.
		worldCamera.viewportWidth = worldWidth;
		worldCamera.viewportHeight = worldHeight;
		
		//Sets the width of the OpenGL ES lines that will draw the level geometry. We take the default width at target resolution, and multiply it by the screen's scale.
		Gdx.gl10.glLineWidth(DEFAULT_LINE_WIDTH * screenScale);
	}
}
