package com.jonathan.survivor.screens;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.InputMultiplexer;
import com.badlogic.gdx.input.GestureDetector;
import com.badlogic.gdx.scenes.scene2d.Stage;
import com.jonathan.survivor.Profile;
import com.jonathan.survivor.Survivor;
import com.jonathan.survivor.World;
import com.jonathan.survivor.hud.BackpackHud;
import com.jonathan.survivor.hud.CraftingHud;
import com.jonathan.survivor.hud.ExplorationHud;
import com.jonathan.survivor.hud.Hud;
import com.jonathan.survivor.hud.HudListener;
import com.jonathan.survivor.hud.PauseMenuHud;
import com.jonathan.survivor.hud.SurvivalGuideHud;
import com.jonathan.survivor.managers.GestureManager;
import com.jonathan.survivor.managers.InputManager;
import com.jonathan.survivor.managers.ItemManager;
import com.jonathan.survivor.renderers.WorldRenderer;

/*
 * Renders the world, updates it, and displays the UI depending on the world's state.
 */

public class GameScreen extends Screen
{
	public enum GameState {
		EXPLORING, BACKPACK, PAUSED, GAME_OVER
	};
	
	/** Stores the state of the game, used to determine how to update the world, and how to draw the UI. */
	private GameState gameState;
	
	/** Stores the game's state before it was paused. Allows the game to resume to its previous game state on resume. */
	private GameState stateBeforePause;
	
	/** Holds true if the game is paused. Prevents the world and the graphics from being updated. */
	private boolean paused;
	
	/** Stores the profile used to create the world. */
	private Profile profile;
	
	/** Holds the ItemManager instance. Its purpose is to give access to Item instances used in the player's inventory, and sprites used inside menus. */
	private ItemManager itemManager;
	
	/** Stores the world, which controls all game logic. */
	private World world;
	/** Stores the world renderer, which takes the objects in the world, and displays them. */
	private WorldRenderer worldRenderer;
	
	/** Manages all simple input of the game such as "touch ups" and calls method of the world's GameObjects to match user input. */
	private InputManager inputManager;
	/** Manages all gestures input of the game such as "swipes" and calls method of the world's GameObjects to match user input. */
	private GestureManager gestureManager;
	
	/** Stores the stage instance where all hud elements will be placed and drawn. */
	private Stage stage;
	
	/** Class allowing us to set multiple instance of InputListeners to receive input events. */
	private InputMultiplexer inputMultiplexer;
	
	/** Stores the currently active Hud which draws the UI to the screen. */
	private Hud hud;
	/** Stores the ExplorationHud instance which draws the UI when the user is in exploration mode. */
	private ExplorationHud explorationHud;
	/** Stores the BackpackHud which displays the Backpack inventory screen. */
	private BackpackHud backpackHud;
	/** Stores the SurvivalGuideHud which displays the survival guide menu. */
	private SurvivalGuideHud survivalGuideHud;
	/** Holds the CraftingHud instance which displays the crafting menu. */
	private CraftingHud craftingHud;
	/** Holds the HUD which displays the pause menu. */
	private PauseMenuHud pauseMenuHud;
	
	/** Stores the UiListener which receives all events related to the UI or the HUD. Used to react appropriately to button presses. */
	private UiListener uiListener;
	
	/** Creates a game screen. The profile used to create the screen must be specified to load the user's previous save information and update it. */
	public GameScreen(Survivor game, Profile profile)
	{
		super(game);
		
		//Stores the profile used to start the game.
		this.profile = profile;
		//Sets the given profile to be saved to the hard drive on application quit.
		settings.setProfile(profile);
		
		//Instantiates an ItemManager, used to retrieve and pool Item instances, along with inventory sprites used to display the items in menus. 
		itemManager = new ItemManager();
		
		//Creates a new World instance, which control game logic. The profile is used to load data pertinent to the world and its contained GameObjects.
		world = new World(profile.getWorldSeed(), profile, itemManager);
		//Creates a world renderer, passing in the world to render, and the SpriteBatcher used to draw the sprites.
		worldRenderer = new WorldRenderer(world, batcher);
		
		//Registers the World to the Settings instance. Player information will be retrieved from this world to be saved to the hard drive.
		settings.setWorld(world);
		
		//Creates a GestureManager with the given world. This manager receieves all gesture events such as swipes and changes the world's GameObjects accordingly.
		inputManager = new InputManager(world, worldRenderer.getWorldCamera());
		//Creates an InputManager with the given world. This manager receives all touch events and reacts by calling appropriate GameObject methods. 
		gestureManager = new GestureManager(world);
		
		//Creates a new stage where 2d widgets for the ui will be displayed.
		stage = new Stage();
		
		//Creates the multiplexer to link several InputListeners together.
		inputMultiplexer = new InputMultiplexer();
		
		//Sets the InputManager to receive simple input events such as touch up/touch down
		inputMultiplexer.addProcessor(inputManager);
		//Sets the GestureManager instance to receive gesture events likes swipes. Must be wrapped in a GestureDetector before being passed as an argument.
		//Arguments: halfTapSquareSize, tapCountInterval, longPressDuration, maxFlingDelay
		inputMultiplexer.addProcessor(new GestureDetector(10, 0.4f, 0.1f, 5f, gestureManager));
		//Adds the stage to the input multiplexer for it to receive input events.
		inputMultiplexer.addProcessor(stage);
		
		//Registers all the input processors from the multiplexer to receive input events.
		Gdx.input.setInputProcessor(inputMultiplexer);
		
		//Creates an ExplorationRenderer which will display the exploration UI using the stage, and will call methods from the world on button clicks.
		explorationHud = new ExplorationHud(stage, world);
		//Instantiates the BackpackHud instance which displays the backpack UI using the stage.
		backpackHud = new BackpackHud(stage, world);
		//Creates the SurvivalGuideHud instance which displays the survival guide menu using the universal stage used for each HUD.
		survivalGuideHud = new SurvivalGuideHud(stage, world);
		//Creates the CraftingHud instance which displays the crafting menu to the screen. Passes the player's inventory, along with the ItemManager to retrieve item Sprites.
		craftingHud = new CraftingHud(stage, world, profile.getInventory(), itemManager);
		//Instantiates a pause menu instance by passing the stage, which indicates that all widgets will be drawn to this stage. The world is unused in the HUD.
		pauseMenuHud = new PauseMenuHud(stage, world);
		
		//Creates the UiListener instance which will receive all events related to the UI and its button presses. 
		uiListener = new UiListener();
		
		//Adds the UiListener instance to each Hud instance. Like this, the GameScreen is informed about button touches in the UI. Used to react appropriately to a button press.
		explorationHud.addHudListener(uiListener);
		backpackHud.addHudListener(uiListener);
		survivalGuideHud.addHudListener(uiListener);
		craftingHud.addHudListener(uiListener);
		pauseMenuHud.addHudListener(uiListener);
		
		//The game always starts off in exploration mode. This tells the class to display the exploration UI for the game.
		setGameState(GameState.EXPLORING);
		
	}
	
	/** Listens to any event that occurs in the HUD of the game. Allows the GameScreen to have knowledge about HUD button presses. */
	public class UiListener implements HudListener
	{
		/** Called when the back button is pressed on any Hud instance. */
		@Override 
		public void onBack()
		{
			//Tells the gameScreen to go back.
			backPressed();
		}
		
		/** Called when the Backpack button is pressed on the exploration HUD. */
		@Override
		public void onBackpackButton()
		{
			//Transitions to the BACKPACK menu and pauses the game so that all input handling related to the game is ignored.
			pauseGame(GameState.BACKPACK);
		}

		/** Delegated when the pause button is pressed whilst in-game. Transitions to the pause menu. */
		@Override
		public void onPauseButton() 
		{
			//Pauses the game and switches to the PAUSED state to show the pause menu and to ensure no input is managed and passed to the world.
			pauseGame(GameState.PAUSED);
		}
		
		/** Called when the user presses/releases a button on a HUD. Toggles input handling on/off. Allows/disallows input from changing the player's state. */ 
		@Override
		public void toggleInput(boolean on) 
		{
			//If the argument is true
			if(on)
				//A button was released. Thus, resume input handling.
				resumeInput();
			//If the given argument is false
			else
				//A button was pressed. Thus, pause input handling.
				pauseInput();
		}
		
		/** Called when the main menu button was pressed in the pause menu. */
		@Override
		public void switchToMainMenu()
		{
			//Saves the game
			settings.save();
			
			//Transitions to the main menu.
			game.setScreen(new MainMenuScreen(game));
		}

		/** Switches to the survival guide HUD when the survival guide button is pressed in the backpack. */
		@Override
		public void switchToSurvivalGuide() 
		{
			//Switches to displaying the survival guide menu.
			hud = survivalGuideHud;
			//Reset the hud so that it displays the survival guide's widgets. Note that the size of the GUI is passed so that widgets are placed according to screen size.
			hud.reset(guiWidth, guiHeight);
		}

		/** Called when the crafting button is pressed in the backpack. Transitions the player to the crafting HUD. */
		@Override
		public void switchToCraftingMenu() 
		{
			//Transitions to displaying the crafting menu.
			hud = craftingHud;
			//Reset the hud so that it displays the crafting HUD's widgets. Note that the size of the GUI is passed so that widgets are placed according to screen size.
			hud.reset(guiWidth, guiHeight);
		}
	}
	
	@Override 
	public void render(float deltaTime)
	{
		//Updates the world.
		update(deltaTime);
		//Draws the world, along with the UI.
		draw(deltaTime);
	}
	
	/** Updates the world and the world camera. */
	private void update(float deltaTime)
	{
		//If the game is not paused
		if(!paused)
		{
			//Update the world and its GameObjects. 
			world.update(deltaTime);
		}
		
		//Update the camera used to view the world.
		worldRenderer.updateCamera();
	}
	
	/** Draws the UI, along with the world and its contained GameObjects. */
	private void draw(float deltaTime)
	{
		//Sets OpenGL to clear the screen with white.
		Gdx.gl.glClearColor(1,1,1,1);
		//Clears the screen.
		super.render(deltaTime);

		//If the game is not paused
		if(!paused)
			//Render and draw the world using the worldRenderer.
			worldRenderer.render(deltaTime);
		//Else, if the game is paused
		else 
			//Render the world with a deltaTime of zero. Pauses animations to ensure that they don't advance in time.
			worldRenderer.render(0);

		
		//Draws the HUD to the screen, depending on game state.
		hud.draw(deltaTime);
	}
	
	/** Delegates when either the hardware back button is pressed, or the back button is pressed from the HUD. */
	private void backPressed()
	{
		//If back button was pressed in the backpack menu
		if(gameState == GameState.BACKPACK)
		{
			//If the player is in the survival guide or the crafting menu, return to the backpack menu
			if(hud instanceof SurvivalGuideHud || hud instanceof CraftingHud)
			{
				//Return to the backpack menu by changing the active HUD.
				hud = backpackHud;
				//Reset the hud to ensure the backpack menu's widgets are placed correctly on screen.
				hud.reset(guiWidth, guiHeight);
			}
			else
			{
				//Resumes the game at its previous game state before being paused. Handles switching game states.
				resumeGame();
			}
			
		}
		//Else, if the back button was pressed in the pause menu
		else if(gameState == GameState.PAUSED)
			//Resumes the game at its previous game state before being paused. Takes care of changing the game state.
			resumeGame();
	}
	
	/** Sets the GameState. Updates the hudRenderer to draw the correct HUD. */
	private void setGameState(GameState state)
	{
		//Update this instance's gameState.
		gameState = state;
		
		//Switch the gameState to change the HUD being rendered.
		switch(gameState)
		{
		case EXPLORING:
			hud = explorationHud;	//Switches to the hud for the game's exploration mode
			break;
		case BACKPACK:
			hud = backpackHud;
			break;
		case PAUSED:
			hud = pauseMenuHud;	//Switches to the pause menu's UI.
			break;
		}
		
		//Tells the renderer to re-place the widgets onto the stage so that the stage contains the correct widgets for the current renderer.
		//Passes the width and height of the gui to ensure that widgets are repositioned and scaled relative to the right resolution.
		hud.reset(guiWidth, guiHeight);
	}
	
	/** Pauses the game whilst running. Called when transitioning to a menu. Accepts the game state the user is switching to. */
	public void pauseGame(GameState newState)
	{
		//Tells the game it is paused and prevents the world and graphics from updating.
		paused = true;
		
		//Stores the game state before pausing. Allows the game to be resumed to its game state before being paused.
		stateBeforePause = gameState;
		//Pauses input processing.
		pauseInput();
		
		//Sets the game state to the new game state. Effectively transitions to the desired HUD for the specified game state.
		setGameState(newState);
	}
	
	/** Resumes the game to its previous state before being paused. */
	public void resumeGame()
	{
		//Resumes the game and permits the world and the graphics from being updated.
		paused = false;
		
		//Sets the game state to its previous state before the game was paused.
		setGameState(stateBeforePause);
		
		//Resumes input processing. Allows the input managers to call the world's methods.
		resumeInput();
	}
	
	/** Pauses the game by pausing all of the input handling. */
	public void pauseInput()
	{
		//Pauses the input manager so that no more touches are delegated to the world.
		inputManager.pause();
		//Pauses the gesture manager so that no more swipes are registered or delegated to the world.
		gestureManager.pause();
	}
	
	/** Resumes the game by allowing the input managers to delegate method calls to the world. */
	public void resumeInput()
	{
		//Resumes the input manager so that it can delegate touch events to the world.
		inputManager.resume();
		//Resumes the gesture manager so that it can delegate events to the world based on swipes.
		gestureManager.resume();
	}
	
	@Override
	public void show() 
	{		
	}

	/** Called when the application is left on Android or when the game is exitted. Saves player information to the hard drive in case of application quit. */
	@Override
	public void pause() 
	{
		//If the player was in the crafting menu upon exit
		if(hud == craftingHud)
			//Ensure that all of the items inside the crafting table get transfered back into the 
			craftingHud.onBack();
		
		//Updates the profile used by the player according to the world's state, and saves the profile to the hard drive.
		settings.save();
	}

	@Override
	public void resume()
	{
	}
	
	@Override
	public void resize(int width, int height)
	{
		//Re-compute the value of the gui/worldWidth and gui/worldHeight superclass variables to ensure that the GUI and the world cameras fits the aspect ratio of
		//the screen.
		super.resize(width, height);
		
		//Set the viewport of the stage to the guiWidth/Height member variables. This ensures that the viewable area of the stage is the desired width and height
		//of the GUI. Note that these variables were defined in the superclass to be the desired default width and height of a GUI. However, the smallest dimension
		//is resized to fit the screen's aspect ratio to avoid uneven stretching. If the device's screen is guiWidth x guiHeight, the GUI is pixel perfect.
		stage.setViewport(guiWidth, guiHeight);
		
		//Resets the HudRenderer currently being used to render the GUI. Re-positions GUI elements to fit screen size. Passes the size of the UI so that the Hud knows
		//how to re-position and resize its widgets accordingly.
		hud.reset(guiWidth, guiHeight);
		
		//Resizes the camera used by the world renderer. We specify the worldWidth and worldHeight. They store the desired size of a camera which displays the world.
		//These values were resized according to the aspect ratio of the screen so that nothing is stretched, and that the world coordinate system stays the same. The
		//third parameter passes the smaller of scaleX and scaleY, telling the renderer to render lines at a larger or smaller thickness depending on how much the
		//smallest dimension had to be scaled. The smallest dimension is taken because the frustum is never stretched more than its smallest dimension.
		worldRenderer.resize(worldWidth, worldHeight, Math.min(screenScaleX, screenScaleY));
	}
	
}
