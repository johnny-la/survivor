package com.jonathan.survivor.screens;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.Texture.TextureFilter;
import com.jonathan.survivor.Assets;
import com.jonathan.survivor.Survivor;
import com.jonathan.survivor.utils.SpriteUtils;

public class CompanySplashScreen extends Screen
{
	private OrthographicCamera guiCamera;	//Stores the camera displaying the GUI (Splash Image).
	
	private static final float TIME_SHOWN = 1.5f;	//Stores the amount of time the splash screen is shown before moving to the loading screen.
	private float timeElapsed;	//Stores the time elapsed since the splash screen started showing.
	
	
	public CompanySplashScreen(Survivor game)
	{
		super(game);
	}
	
	@Override
	public void show() 
	{
		//Load the assets needed to display the CompanySplashScreen. This loads the splash screen image, along with the textures needed to draw
		//the loading screen right after
		assets.loadInitialAssets();
		
		//Creates a new GUI camera with a default width and height defined by the Screen superclass.
		guiCamera = new OrthographicCamera(guiWidth, guiHeight);
		
		//Render the splash screen once before loading the assets needed by the loading screen.
		render(Gdx.graphics.getDeltaTime());
		
		//Loads the assets that will be needed when the user switches to the loading screen. Certain elements, such as fonts and the player, need to be loaded.
		assets.loadSplashScreenAssets();
	}
	
	@Override
	public void render(float deltaTime)
	{
		//Sets OpenGL to clear the screen with black.
		Gdx.gl.glClearColor(0,0,0,1);
		//Clears the screen
		super.render(deltaTime);
		
		//Draws the splash screen and its various elements to the screen.
		draw(deltaTime);
		
		//Updates the splash screen. Must be called after the render call. When switching to the loading screen, no more statements can be executed, and thus draw() can't be below.
		update(deltaTime);
	}
	
	/** Updates the widgets of the splash screen and its game logic before rendering them every frame. */
	private void update(float deltaTime) 
	{
		//Increment the time elapsed since the splash screen started showing by deltaTime. This keeps track of when we should exit the screen.
		timeElapsed += deltaTime;
		
		//If the splash screen has been shown for a time greater than the maximum time it should be shown, switch to the loading screen.
		if(timeElapsed > TIME_SHOWN || game.DEBUG_MODE)
		{
			//Switch to the loading screen.
			game.setScreen(new LoadingScreen(game));
			return;
		}
	}

	/** Draws the splash screen and all of its widgets. */
	private void draw(float deltaTime)
	{
		//Sets the batcher's projection matrix to the camera's (mandatory)
		batcher.setProjectionMatrix(guiCamera.combined);
		//Begin batching sprites.
		batcher.begin();
		
		//Set the center position of the companyLogo sprite to (0,0) (center of the camera).
		SpriteUtils.setPosition(assets.companyLogo, 0, 35);
		SpriteUtils.setPosition(assets.mugishaLogo, 0, -40);
		//Draw the companyLogo sprite.
		assets.companyLogo.draw(batcher);
		assets.mugishaLogo.draw(batcher);
		
		//Draw the sprites batched inside the batcher.
		batcher.end();
	}

	@Override
	public void pause() 
	{
	}

	@Override
	public void resume() 
	{		
	}
	
	@Override
	public void resize(int width, int height)
	{
		//Update the super.guiWidth/Height variables
		super.resize(width, height);
		
		//Update the viewport width and height of the GUI camera using the superclass variables guiWidth/Height. Inside super.resize(), these variables
		//were re-computed so that the aspect ratio of the guiCamera would fit the new screen size. This prevents scaling more in one axis than another.
		guiCamera.viewportWidth = guiWidth;
		guiCamera.viewportHeight = guiHeight;
		
		//Update the GUI camera to apply size changes.
		guiCamera.update();
	}
	
}
