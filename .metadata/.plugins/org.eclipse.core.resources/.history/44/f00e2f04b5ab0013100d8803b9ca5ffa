package com.jonathan.survivor.managers;

import com.badlogic.gdx.utils.Array;
import com.jonathan.survivor.inventory.Axe;
import com.jonathan.survivor.inventory.Bullet;
import com.jonathan.survivor.inventory.Charcoal;
import com.jonathan.survivor.inventory.Gunpowder;
import com.jonathan.survivor.inventory.Iron;
import com.jonathan.survivor.inventory.Saltpeter;
import com.jonathan.survivor.inventory.Sulfur;
import com.jonathan.survivor.inventory.Water;
import com.jonathan.survivor.inventory.Wood;

public class CraftingManager 
{
	/** Holds the singleton instance to the CraftingManager. */
	public static final CraftingManager instance = new CraftingManager();
	
	/** Stores an array of all possible crafting combinations. */
	private Array<Combination> combinations;
	
	/** Holds all of the possible crafting combinations. */
	public Combination axe, gunpowder, bullet;
	
	private CraftingManager()
	{
		//Creates the array which will hold all crafting combinations.
		combinations = new Array<Combination>();
		
		//Creates all of the different crafting combinations in the game.
		axe = new Combination();
		axe.addItem(Iron.class, 5);
		axe.addItem(Wood.class, 10);
		axe.setResult(Axe.class, 1);
		
		gunpowder = new Combination();
		gunpowder.addItem(Saltpeter.class, 12);
		gunpowder.addItem(Charcoal.class, 8);
		gunpowder.addItem(Sulfur.class, 6);
		gunpowder.addItem(Water.class, 4);
		gunpowder.setResult(Gunpowder.class, 13);
		
		bullet = new Combination();
		bullet.addItem(Water.class, 1);
		bullet.setResult(Bullet.class, 1);
		
		//Adds all of the combinations into an array
		combinations.add(axe);
		combinations.add(gunpowder);
		combinations.add(bullet);
	}
	
	/** Returns the resulting item crafted using the given array of items. If null, no result is formed using the given list of items. */
	public Item getResult(Array<Item> items)
	{
		//Cycles through the list of all possible combinations.
		for(int i = 0; i < combinations.size; i++)
		{
			//If the combination matches the list of given items
			if(combinations.get(i).validItems(items))
				//Return the result of the combination which is formed by the given items.
				return combinations.get(i).getResult();
		}
		
		//If this statement is reached, the items don't form any possible combination. Thus, return null.
		return null;
	}
	
	/** Describes a combination of items which together craft an item. */
	private class Combination
	{		
		/** Stores the item which results from the combination. */
		private Item result;
		
		/** The array of items which must be combined to form the above the resulting item. */
		private Array<Item> items;
		
		/** Creates a new, empty combination. */
		public Combination()
		{
			items = new Array<Item>();
		}
		
		/** Adds a specific item to the combination. */
		public void addItem(Class item, int quantity)
		{
			//Adds the item to the list of items in the combination.
			items.add(new Item(item, quantity));
		}

		/** Tests if the given list of items corresponds to the items needed in this combination. Returns true if the given list of items form this combination. */
		public boolean validItems(Array<Item> givenItems)
		{
			//If the amount of given items is not the same as the amount of items in the combination, the given items don't form this combination. Thus, return false.
			if(givenItems.size != items.size)
				return false;
			
			//Cycles through the items needed to form the combination
			for(int i = 0; i < items.size; i++)
			{
				//Checks if the given items contain this combination's items. The second boolean ensures that 'equals()' comparison is used.
				if(givenItems.contains(items.get(i), true))
				{
				}
				else
				{
					return false;
				}
			}
			
			//If this statement is reached, the given items produce the combination's result. So, return true.
			return true;
		}
		
		/** Sets the resulting item from the crafting combination */
		public Item getResult() {
			return result;
		}

		/** Gets the resulting item from the crafting combination */
		public void setResult(Class item, int quantity) {
			this.result = new Item(item, quantity);
		}
	}
	
	/** Pairs an item with a specific quantity for use inside a Combination. */
	public class Item
	{
		private int quantity;	//Stores the quantity of the item needed in a combination
		private Class item;	//Holds the item needed in a combination
		
		/** Creates a pair between an item and a specific quantity. */
		public Item(Class item, int quantity)
		{
			this.item = item;
			this.quantity = quantity;
		}
		
		/** Adds the given quantity to this item instance. */
		public void add(int quantity)
		{
			//Increments the quantity integer by the given amount.
			this.quantity += quantity;
		}
		
		//Returns true if the given item is equal to this item.
		public boolean equals(Item other)
		{
			return other.item == this.item && other.quantity == this.quantity;
		}
		
		/** Gets the item class held by this instance. */
		public Class getItem() {
			return item;
		}
		
		/** Sets the item class held by this instance. */
		public void setItem(Class item) {
			this.item = item;
		}

		/** Gets the quantity of the item. */
		public int getQuantity() {
			return quantity;
		}
		
		/** Sets the quantity of the item. */
		public void setQuantity(int quantity) {
			this.quantity = quantity;
		}
		
		public String toString()
		{
			return item + ": " + quantity;
		}
	}
}
